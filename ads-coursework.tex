\documentclass[11pt,a4paper]{article}

\usepackage{verbatim}
\usepackage{graphicx}

\title{Advanced Database Systems Coursework}
\author{Ross Fenning}

\begin{document}

\maketitle

\section{Introduction}

The aim of this report is to explore and compare the different properties of
three different kinds of databases beyond the traditional relational model. In it,
the same dataset will be modelled in each of an \emph{Object-Relational} database,
an \emph{XML} database and a \emph{Document} database.

A suggested structure or schema will be designed for each database type, then
each design will be implemented in each of \emph{PostgreSQL}, \emph{eXist}
and \emph{MongoDB} along with a discussion around how each database would be
queried for different use cases.

Finally, there will be a comparitive discussion around the advantages and
disadvantages between the different database types, including which the use
cases to which each kind of database are most appropriate.

\section{The Data}

The dataset that will be used is a small set of 7,788 TV and radio programmes
that have been available to listen to or watch on some form of catch-up
service (e.g. the old radio ``Listen Again'' service or BBC iPlayer) between
2001 and 2012.

The raw data begin in a comma-separated format, with each row representing
a single programme. Each programme row comprises:

\begin{itemize}
    \item an identifier known as a \emph{pid} (programme ID);
    \item a start and end time (in both Unix timestamp and ISO 8601 formats);
    \item a title;
    \item a media type (i.e. audio or video);
    \item the master brand with which the programme is associated (somewhat
      correlated with the channel that broadcasted the programme, e.g.
      BBC Radio Four or BBC Two);
    \item the service that did broadcast the programme originally;
    \item a pid identifier for the programme's brand (e.g. for an episode of
      Doctor Who this would be the identifier for the Doctor Who concept
      in general);
    \item whether or not this is a programme or a just a clip that was
      available to watch/listen to;
    \item any categories associated with the programme; and
    \item any tags set against the programme.
\end{itemize}

We might imagine that this will form the basis of a whole archive of BBC
TV and radio programmes with a variety of use cases for such an archive.
Potential uses for such a database will be discussed as different designs
and approaches are used to import this information into three different
database systems.

\section{Object-Relational}

The Object-Relational database system used here is PostgreSQL, which supports
pure relational databases and SQL, but also has support for objects and
inheritance to support an aggregate-oriented approach, where we can store
aggregates of data together as single objects for atomic updates against
them or simply to group information together into logical objects. This
takes us somewhat away from the pure relational model where data aggregation
is distributed across relations between many tuples. \cite{sadalage2012nosql}

\subsection{Design}

The first benefit of the relational model (which is treated here as a strict
subset of the object-relational model) is that our comma-separated source
data can be na\"ively imported as a single relation, with one row of the CSV
file being stored as exactly one row in the relation. This is shown in
Figure~\ref{fig:single-relation}. This seems
to be the path of least resistance if we simply want to stage the data
in a database system quickly so as to begin queries against it, but is
likely losing some of the benefits of the relational model and is unlikely
to be in a normal form.

We can proceed initially to normalise the table as far as possible in
a pure relational model and then look to see what benefits can be gained
from introducing objects as in the object-relational model.

\subsubsection{Pure Relational Model}

\begin{comment}
  @startuml plant_single_relation.png
  class Programme {
    pid
    start_time
    end_time
    epoch_start
    epoch_end
    complete_title
    media_type
    masterbrand
    service
    brand_pid
    is_clip
    categories
    tags
  }
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=1in]{plant_single_relation.png}
  \end{center}
  \caption{Representing the dataset as a single relation}
  \label{fig:single-relation}
\end{figure}

The other problem with importing a whole row into a single relation is that
a pure relational database system is probably not going to be able to deal
with the categories and tags columns, which are both lists. Without support
for lists or arrays, the only compromise we would have is to import them
as raw string types and leave it to the application code to parse and break
apart those strings to derive further meaning from them. The consequence of
this is that there is no elegant way to query based on the contents of
the categories or tags fields, which is unhelpful if the intention is to
serve an application that wishes to allow searching by tag or category.

The presence of multiple values in the categories and tags fields already
means our single relation model is not even in First Normal Form (1NF).
\cite{codd1972further}
An obvious next step is to create relations for categories and for tags,
with relations. This would produce something similar to
Figure~\ref{fig:cat-tags-rel}.

\begin{comment}
  @startuml plant_three_relations.png
  class Programme {
    pid
    start_time
    end_time
    epoch_start
    epoch_end
    complete_title
    media_type
    masterbrand
    service
    brand_pid
    is_clip
  }
  class Category {
    id
    level
    title
  }
  class Tag {
    title
  }
  Programme "0..*" -r- "0..*" Category
  Programme "0..*" -l- "0..*" Tag
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_three_relations.png}
  \end{center}
  \caption{Relations created for the list/set types}
  \label{fig:cat-tags-rel}
\end{figure}

The schema so far is still not in Second Normal Form (2NF),
however. Whilst it may not be the case in the exact data set
at hand, there is a distinct possibility we will want our database
to store a programme that has been repeated and thus becomes eligible
for watching on a catch-up service within a second window of time.
In this case the best candidate key for the table would be a tuple
including the pid and at least the start time (if not the end time
as well) of the catch-up availability window.

With a composite key of the pid and the time, we can clearly see
that non-prime attributes such as the programme's master brand, tags
or media type are dependent on just the programme identifier subset
of the key, not the time slots. Thus if we wish to take our schema
design into 2NF, we need to break apart the programme information
and the time windows into their own relations as shown in
Figure~\ref{fig:2nf}.

\begin{comment}
  @startuml plant_2nf.png
  class Programme {
    pid
    complete_title
    media_type
    masterbrand
    brand_pid
    is_clip
  }
  class AvailabilityWindow {
    start_time
    end_time
    epoch_start
    epoch_end
    service
  }
  class Category {
    id
    level
    title
  }
  class Tag {
    title
  }
  Programme "1" -d- "0..*" AvailabilityWindow
  Programme "0..*" -r- "0..*" Category
  Programme "0..*" -l- "0..*" Tag
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_2nf.png}
  \end{center}
  \caption{Programme and availability windows separated for 2NF}
  \label{fig:2nf}
\end{figure}

So, the remaining problem that is keeping the design from being in
Third Normal Form (3NF) is there is a functional dependency
between the start and end timestamps and the same times expressed
in ISO 8601 format. Rather than this being a case for refactoring
out to another relation however, we can simply opt to store
our start and end times in a single format and leave it up to queries
to choose to convert to the desired format later on. In fact, the
\emph{timestamp} data type with PostgreSQL is perfectly suitable
here. This then leaves us with our final relational model in 3NF
as shown in Figure~\ref{fig:3nf}

\begin{comment}
  @startuml plant_3nf.png
  class Programme {
    pid : varchar
    complete_title : varchar
    media_type : enum ('video, 'audio')
    masterbrand : varchar
    brand_pid : varchar
    is_clip : boolean
  }
  class AvailabilityWindow {
    start_time : timestamp
    end_time : timestamp
    service : varchar
  }
  class Category {
    id : varchar
    level : smallint
    title : varchar
  }
  class Tag {
    title : varchar
  }
  Programme "1" -d- "0..*" AvailabilityWindow
  Programme "0..*" -r- "0..*" Category
  Programme "0..*" -l- "0..*" Tag
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_3nf.png}
  \end{center}
  \caption{Removed date redundancy allows the model to be in 3NF}
  \label{fig:3nf}
\end{figure}

We might find that we can achieve stricter normal forms with
media type being dependent on the service or the master brand
(i.e. radio services will only broadcast audio and TV services
will always broadcast video), but for this design we will stop short
of looking to go into Forth Normal Form (4NF) or stricter.
\cite{fagin1977multivalued}
In a real business application, it's hard to make that assumption
without confirmation of the requirements (maybe a TV service will
broadcast an audio-only programme one day). It is also something to keep in
mind given that tables found to be violating 4NF can be very common
in business applications. \cite{wu1992practical} In our case, it is
entirely possible for a client application to insert a programme on
BBC Radio Four with the media type \emph{video}. Before building
this database for a real application, we would likely clarify whether
that is an acceptable state or whether such a row would be considered
inconsistent.

When we come to implement the entities and their respective relations
as shown in figure~\ref{fig:3nf}, we would create the following relations:

\begin{enumerate}
  \item Programme(pid, complete\_title, media\_type, masterbrand, brand\_pid, is\_clip)
  \item AvailabilityWindow(pid, start\_time, end\_time, service)
  \item Category(id, level, title)
  \item ProgrammeCategory(pid, category\_id)
  \item Tag(title)
  \item ProgrammeTag(pid, title)
\end{enumerate}

So, what benefits can we can from the non-SQL or object-like features of
PostgreSQL over and above the pure relational mode?

\subsubsection{Aggregate model and array fields}

If we wanted to search for a set of programmes along with their tags, we would
have to do a JOIN query each time. With very large Programme and Tag tables, this
JOIN could get very expensive -- especially with complex filtering involved.

In a more aggregate-oriented approach, we could treat the tags as an
intrinsic part of a programme \emph{aggregate} -- we would only want to update
the tags within the context of updating a programme and we're hardly
ever likely to query a Tag relation independently of the Programme relation.
With this, we could employ an array type within PostgreSQL with either the
arrays pointing to a table of all potential Tag values
(using \emph{ELEMENT REFERENCES})
or the arrays containing string values of the tags themselves. With string
arrays, we lose the consistency of being able to update a tag itself (say,
for spelling corrections), but we have a far faster way of changing the tags
of a programme whilst updating the programme aggregate as a whole.

Note that updating the aggregate atomically in this way removes the need
to use transactions, which would be necessary if we were both updating the
Tag and Programme relations in a single update. Again, we could see some
real performance gains if this database were receiving a lot of updates and
would otherwise be subject to a lot of locking and contention. \cite{sadalage2012nosql}

The consistency then arguably becomes easier to maintain were we to scale
to a distributed database model. If a programme is modelled as an aggregate
containing its own tags, then an atomic update of a programme and its tags
can be replicated across nodes eventually without worry that the update
to the programme may synchronise before the update containg the new tag it's
supposed to have gained. In the pure relational model, we would have used
transactions to keep the two updates together; with the aggregate model,
that need is removed.

The key to a lot of this debate around the tags for a programme really lies
in how the business intends for that information to be used. Generally,
the concept of tagging is a loose way to add textual metadata to a
business object to aid searches, automatic aggregation and even data
mining potential (e.g. this user likes things with this particular tag,
so we can suggest them more content with similar tags).

Tagging is something that can even somewhat benefit from being unconstrained
and freely chosen as the item is added or updated. \cite{smith2008tagging}
It is also arguable that the harm in a tag being spelled incorrectly
on one programme is a minor harm (given it is additional metadata that
does not harm normal navigation nor basic application functions) when
compared to the benefit given to editors and content producers that
they can add as many tags freely as they please to their content items.

\subsubsection{Modelling programme categories}

Can we apply the same reasoning to the categories? Similarly to the
tags, we could consider adding them as an array type within the
Programme relation. Given they are more complex entities, we could
not easily store them as primitive strings, but the possibility of an
array of foreign key references to the Category relation is there. Another
option is that of an array of a custom \emph{composite} type.

With a composite type, we could create a category type and use that within
an array in our Programme relation. However, categories are likely to be
used very differently to tags in that they are commonly used to
drive hierarchical navigation in a user interface, allowing users
to browse categories of interest for the latest or most popular items
therewithin.

Given that we might (almost) equally query for programmes or categories,
we probably still want to keep their respective relations and rely on
JOIN queries to link the two when needed. It is not unreasonable to
expect an application where the categories themselves are rarely changed,
but programmes are individually added in frequent updates against these
relatively static categories. Thus we would have rare need for rapid,
expensive transactions where both tables need updating atomically. In
the rare cases where a category is added along with a programme,
we could easily pay the performance cost on such a one-off update.

The option of a composite type should be kept for consideration (perhaps
if further requirements gathering indicates it is a better approach),
but with the assumptions made so far, there seems to be little
case for it.

Another question is whether to model the hierarchical nature of the
category entity. The level attribute of a category (so far only values
\emph{1} and \emph{2} are observed) hints at a category hierarchy with
level 1 categories being root categories and level 2 categories being
children thereof. It is possible to model this using table
\emph{inheritence} within PostgreSQL. In this case, we could define
a Subcategory table that inherits the identifier and title attributes
from the Category table, but additionally adds a reference to any
other (sub)category indicating its parent.

Taking the approach of making tags string arrays within the programme
aggregate (for simplicity, performance and atomic updates) and using
inheritence to maintain a category hierarchy, we arrive at a final
candidate entity relationship design as shown in figure~\ref{fig:final_postgres}.

\begin{comment}
  @startuml plant_final_postgres.png
  class Programme {
    pid : varchar
    complete_title : varchar
    media_type : enum ['video, 'audio']
    masterbrand : varchar
    brand_pid : varchar
    is_clip : boolean
    tags : varchar[]
  }
  class AvailabilityWindow {
    start_time : timestamp
    end_time : timestamp
    service : varchar
  }
  class Category {
    id : varchar
    title : varchar
  }
  class Subcategory extends Category {
    parent : Category
  }
  Programme "1" -d- "0..*" AvailabilityWindow
  Programme "0..*" -r- "0..*" Category
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_final_postgres.png}
  \end{center}
  \caption{Candidate final design for PostgresSQL database}
  \label{fig:final_postgres}
\end{figure}


\subsection{Implementation}
\subsection{Querying}

\section{XML Database}
\subsection{Design}
\subsection{Implementation}
\subsection{Querying}

\section{Document Database}
\subsection{Design}
\subsection{Implementation}
\subsection{Querying}

\section{Comparison}

\bibliographystyle{cell}
\bibliography{bibtex}
\end{document}
