\documentclass[11pt,a4paper]{article}

\usepackage{verbatim}
\usepackage{graphicx}

\title{Advanced Database Systems Coursework}
\author{Ross Fenning}

\begin{document}

\maketitle

\section{Introduction}

The aim of this report is to explore and compare the different properties of
three different kinds of databases beyond the traditional relational model. In it,
the same dataset will be modelled in each of an \emph{Object-Relational} database,
an \emph{XML} database and a \emph{Document} database.

A suggested structure or schema will be designed for each database type, then
each design will be implemented in each of \emph{PostgreSQL}, \emph{eXist}
and \emph{MongoDB} along with a discussion around how each database would be
queried for different use cases.

Finally, there will be a comparitive discussion around the advantages and
disadvantages between the different database types, including which the use
cases to which each kind of database are most appropriate.

\section{The Data}

The dataset that will be used is a small set of 7,788 TV and radio programmes
that have been available to listen to or watch on some form of catch-up
service (e.g. the old radio ``Listen Again'' service or BBC iPlayer) between
2001 and 2012.

The raw data begin in a comma-separated format, with each row representing
a single programme. Each programme row comprises:

\begin{itemize}
    \item an identifier known as a \emph{pid} (programme ID);
    \item a start and end time (in both Unix timestamp and ISO 8601 formats);
    \item a title;
    \item a media type (i.e. audio or video);
    \item the master brand with which the programme is associated (somewhat
      correlated with the channel that broadcasted the programme, e.g.
      BBC Radio Four or BBC Two);
    \item the service that did broadcast the programme originally;
    \item a pid identifier for the programme's brand (e.g. for an episode of
      Doctor Who this would be the identifier for the Doctor Who concept
      in general);
    \item whether or not this is a programme or a just a clip that was
      available to watch/listen to;
    \item any categories associated with the programme; and
    \item any tags set against the programme.
\end{itemize}

We might imagine that this will form the basis of a whole archive of BBC
TV and radio programmes with a variety of use cases for such an archive.
Potential uses for such a database will be discussed as different designs
and approaches are used to import this information into three different
database systems.

\section{Object-Relational}

The Object-Relational database system used here is PostgreSQL, which supports
pure relational databases and SQL, but also has support for objects and
inheritance to support an aggregate-oriented approach, where we can store
aggregates of data together as single objects for atomic updates against
them or simply to group information together into logical objects. This
takes us somewhat away from the pure relational model where data aggregation
is distributed across relations between many tuples. \cite{sadalage2012nosql}

\subsection{Design}

The first benefit of the relational model (which is treated here as a strict
subset of the object-relational model) is that our comma-separated source
data can be na\"ively imported as a single relation, with one row of the CSV
file being stored as exactly one row in the relation. This is shown in
Figure~\ref{fig:single-relation}. This seems
to be the path of least resistance if we simply want to stage the data
in a database system quickly so as to begin queries against it, but is
likely losing some of the benefits of the relational model and is unlikely
to be in a normal form.

\begin{comment}
  @startuml plant_single_relation.png
  class Programme {
    pid
    start_time
    end_time
    epoch_start
    epoch_end
    complete_title
    media_type
    masterbrand
    service
    brand_pid
    is_clip
    categories
    tags
  }
  @enduml
\end{comment}
\begin{figure}[h]
  \begin{center}
    \includegraphics[width=1in]{plant_single_relation.png}
  \end{center}
  \caption{Representing the dataset as a single relation}
  \label{fig:single-relation}
\end{figure}

The other problem with importing a whole row into a single relation is that
a pure relational database system is probably not going to be able to deal
with the categories and tags columns, which are both lists. Without support
for lists or arrays, the only compromise we would have is to import them
as raw string types and leave it to the application code to parse and break
apart those strings to derive further meaning from them. The consequence of
this is that there is no elegant way to query based on the contents of
the categories or tags fields, which is unhelpful if the intention is to
serve an application that wishes to allow searching by tag or category.

The presence of multiple values in the categories and tags fields already
means our single relation model is not even in First Normal Form (1NF).
\cite{codd1972further}
An obvious next step is to create relations for categories and for tags,
with relations. This would produce something similar to
Figure~\ref{fig:cat-tags-rel}.

\begin{comment}
  @startuml plant_three_relations.png
  class Programme {
    pid
    start_time
    end_time
    epoch_start
    epoch_end
    complete_title
    media_type
    masterbrand
    service
    brand_pid
    is_clip
  }
  class Category {
    id
    level
    title
  }
  class Tag {
    title
  }
  Programme "0..*" -r- "0..*" Category
  Programme "0..*" -l- "0..*" Tag
  @enduml
\end{comment}
\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_three_relations.png}
  \end{center}
  \caption{Relations created for the list/set types}
  \label{fig:cat-tags-rel}
\end{figure}

\subsection{Implementation}
\subsection{Querying}

\section{XML Database}
\subsection{Design}
\subsection{Implementation}
\subsection{Querying}

\section{Document Database}
\subsection{Design}
\subsection{Implementation}
\subsection{Querying}

\section{Comparison}

\bibliographystyle{cell}
\bibliography{bibtex}
\end{document}
