\documentclass[11pt,a4paper]{article}

\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{listings}
\lstset{
  breakatwhitespace=true,
  breaklines=true,
  frame=single
}

\title{Advanced Database Systems Coursework}
\author{Ross Fenning}

\begin{document}

\maketitle

\section{Introduction}

The aim of this report is to explore and compare the different properties of
three different kinds of databases beyond the traditional relational model. In it,
the same dataset will be modelled in each of an \emph{Object-Relational} database,
an \emph{XML} database and a \emph{Document} database.

A suggested structure or schema will be designed for each database type, then
each design will be implemented in each of \emph{PostgreSQL}, \emph{eXist}
and \emph{MongoDB} along with a discussion around how each database would be
queried for different use cases.

Finally, there will be a comparitive discussion around the advantages and
disadvantages between the different database types, including which the use
cases to which each kind of database are most appropriate.

\section{The Data}

The dataset that will be used is a small set of 7,788 TV and radio programmes
that have been available to listen to or watch on some form of catch-up
service (e.g. the old radio ``Listen Again'' service or BBC iPlayer) between
2001 and 2012.

The raw data begin in a comma-separated format, with each row representing
a single programme. Each programme row comprises:

\begin{itemize}
    \item an identifier known as a \emph{pid} (programme ID);
    \item a start and end time (in both Unix timestamp and ISO 8601 formats);
    \item a title;
    \item a media type (i.e. audio or video);
    \item the master brand with which the programme is associated (somewhat
      correlated with the channel that broadcasted the programme, e.g.
      BBC Radio Four or BBC Two);
    \item the service that did broadcast the programme originally;
    \item a pid identifier for the programme's brand (e.g. for an episode of
      Doctor Who this would be the identifier for the Doctor Who concept
      in general);
    \item whether or not this is a programme or a just a clip that was
      available to watch/listen to;
    \item any categories associated with the programme; and
    \item any tags set against the programme.
\end{itemize}

We might imagine that this will form the basis of a whole archive of BBC
TV and radio programmes with a variety of use cases for such an archive.
Potential uses for such a database will be discussed as different designs
and approaches are used to import this information into three different
database systems.

\section{Object-Relational}
\label{sec:postgres}

The Object-Relational database system used here is PostgreSQL, which supports
pure relational databases and SQL, but also has support for objects and
inheritance to support an aggregate-oriented approach, where we can store
aggregates of data together as single objects for atomic updates against
them or simply to group information together into logical objects. This
takes us somewhat away from the pure relational model where data aggregation
is distributed across relations between many tuples. \cite{sadalage2012nosql}

\subsection{Design}

The first benefit of the relational model (which is treated here as a strict
subset of the object-relational model) is that our comma-separated source
data can be na\"ively imported as a single relation, with one row of the CSV
file being stored as exactly one row in the relation. This is shown in
Figure~\ref{fig:single-relation}. This seems
to be the path of least resistance if we simply want to stage the data
in a database system quickly so as to begin queries against it, but is
likely losing some of the benefits of the relational model and is unlikely
to be in a normal form.

We can proceed initially to normalise the table as far as possible in
a pure relational model and then look to see what benefits can be gained
from introducing objects as in the object-relational model.

\subsubsection{Pure Relational Model}

\begin{comment}
  @startuml plant_single_relation.png
  class Programme {
    pid
    start_time
    end_time
    epoch_start
    epoch_end
    complete_title
    media_type
    masterbrand
    service
    brand_pid
    is_clip
    categories
    tags
  }
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=1in]{plant_single_relation.png}
  \end{center}
  \caption{Representing the dataset as a single relation}
  \label{fig:single-relation}
\end{figure}

The other problem with importing a whole row into a single relation is that
a pure relational database system is probably not going to be able to deal
with the categories and tags columns, which are both lists. Without support
for lists or arrays, the only compromise we would have is to import them
as raw string types and leave it to the application code to parse and break
apart those strings to derive further meaning from them. The consequence of
this is that there is no elegant way to query based on the contents of
the categories or tags fields, which is unhelpful if the intention is to
serve an application that wishes to allow searching by tag or category.

The presence of multiple values in the categories and tags fields already
means our single relation model is not even in First Normal Form (1NF).
\cite{codd1972further}
An obvious next step is to create relations for categories and for tags,
with relations. This would produce something similar to
Figure~\ref{fig:cat-tags-rel}.

\begin{comment}
  @startuml plant_three_relations.png
  class Programme {
    pid
    start_time
    end_time
    epoch_start
    epoch_end
    complete_title
    media_type
    masterbrand
    service
    brand_pid
    is_clip
  }
  class Category {
    id
    level
    title
  }
  class Tag {
    title
  }
  Programme "0..*" -r- "0..*" Category
  Programme "0..*" -l- "0..*" Tag
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_three_relations.png}
  \end{center}
  \caption{Relations created for the list/set types}
  \label{fig:cat-tags-rel}
\end{figure}

The schema so far is still not in Second Normal Form (2NF),
however. Whilst it may not be the case in the exact data set
at hand, there is a distinct possibility we will want our database
to store a programme that has been repeated and thus becomes eligible
for watching on a catch-up service within a second window of time.
In this case the best candidate key for the table would be a tuple
including the pid and at least the start time (if not the end time
as well) of the catch-up availability window.

With a composite key of the pid and the time, we can clearly see
that non-prime attributes such as the programme's master brand, tags
or media type are dependent on just the programme identifier subset
of the key, not the time slots. Thus if we wish to take our schema
design into 2NF, we need to break apart the programme information
and the time windows into their own relations as shown in
Figure~\ref{fig:2nf}.

\begin{comment}
  @startuml plant_2nf.png
  class Programme {
    pid
    complete_title
    media_type
    masterbrand
    brand_pid
    is_clip
  }
  class AvailabilityWindow {
    start_time
    end_time
    epoch_start
    epoch_end
    service
  }
  class Category {
    id
    level
    title
  }
  class Tag {
    title
  }
  Programme "1" -d- "0..*" AvailabilityWindow
  Programme "0..*" -r- "0..*" Category
  Programme "0..*" -l- "0..*" Tag
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_2nf.png}
  \end{center}
  \caption{Programme and availability windows separated for 2NF}
  \label{fig:2nf}
\end{figure}

So, the remaining problem that is keeping the design from being in
Third Normal Form (3NF) is there is a functional dependency
between the start and end timestamps and the same times expressed
in ISO 8601 format. Rather than this being a case for refactoring
out to another relation however, we can simply opt to store
our start and end times in a single format and leave it up to queries
to choose to convert to the desired format later on. In fact, the
\emph{timestamp} data type with PostgreSQL is perfectly suitable
here. This then leaves us with our final relational model in 3NF
as shown in Figure~\ref{fig:3nf}

\begin{comment}
  @startuml plant_3nf.png
  class Programme {
    pid : varchar
    complete_title : varchar
    media_type : enum ('video, 'audio')
    masterbrand : varchar
    brand_pid : varchar
    is_clip : boolean
  }
  class AvailabilityWindow {
    start_time : timestamp
    end_time : timestamp
    service : varchar
  }
  class Category {
    id : varchar
    level : smallint
    title : varchar
  }
  class Tag {
    title : varchar
  }
  Programme "1" -d- "0..*" AvailabilityWindow
  Programme "0..*" -r- "0..*" Category
  Programme "0..*" -l- "0..*" Tag
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_3nf.png}
  \end{center}
  \caption{Removed date redundancy allows the model to be in 3NF}
  \label{fig:3nf}
\end{figure}

We might find that we can achieve stricter normal forms with
media type being dependent on the service or the master brand
(i.e. radio services will only broadcast audio and TV services
will always broadcast video), but for this design we will stop short
of looking to go into Forth Normal Form (4NF) or stricter.
\cite{fagin1977multivalued}
In a real business application, it's hard to make that assumption
without confirmation of the requirements (maybe a TV service will
broadcast an audio-only programme one day). It is also something to keep in
mind given that tables found to be violating 4NF can be very common
in business applications. \cite{wu1992practical} In our case, it is
entirely possible for a client application to insert a programme on
BBC Radio Four with the media type \emph{video}. Before building
this database for a real application, we would likely clarify whether
that is an acceptable state or whether such a row would be considered
inconsistent.

When we come to implement the entities and their respective relations
as shown in figure~\ref{fig:3nf}, we would create the following relations:

\begin{enumerate}
  \item Programme(pid, complete\_title, media\_type, masterbrand, brand\_pid, is\_clip)
  \item AvailabilityWindow(pid, start\_time, end\_time, service)
  \item Category(id, level, title)
  \item ProgrammeCategory(pid, category\_id)
  \item Tag(title)
  \item ProgrammeTag(pid, title)
\end{enumerate}

So, what benefits can we can from the non-SQL or object-like features of
PostgreSQL over and above the pure relational mode?

\subsubsection{Aggregate model and array fields}

If we wanted to search for a set of programmes along with their tags, we would
have to do a JOIN query each time. With very large Programme and Tag tables, this
JOIN could get very expensive -- especially with complex filtering involved.

In a more aggregate-oriented approach, we could treat the tags as an
intrinsic part of a programme \emph{aggregate} -- we would only want to update
the tags within the context of updating a programme and we're hardly
ever likely to query a Tag relation independently of the Programme relation.
With this, we could employ an array type within PostgreSQL with either the
arrays pointing to a table of all potential Tag values
(using \emph{ELEMENT REFERENCES})
or the arrays containing string values of the tags themselves. With string
arrays, we lose the consistency of being able to update a tag itself (say,
for spelling corrections), but we have a far faster way of changing the tags
of a programme whilst updating the programme aggregate as a whole.

Note that updating the aggregate atomically in this way removes the need
to use transactions, which would be necessary if we were both updating the
Tag and Programme relations in a single update. Again, we could see some
real performance gains if this database were receiving a lot of updates and
would otherwise be subject to a lot of locking and contention. \cite{sadalage2012nosql}

The consistency then arguably becomes easier to maintain were we to scale
to a distributed database model. If a programme is modelled as an aggregate
containing its own tags, then an atomic update of a programme and its tags
can be replicated across nodes eventually without worry that the update
to the programme may synchronise before the update containg the new tag it's
supposed to have gained. In the pure relational model, we would have used
transactions to keep the two updates together; with the aggregate model,
that need is removed.

The key to a lot of this debate around the tags for a programme really lies
in how the business intends for that information to be used. Generally,
the concept of tagging is a loose way to add textual metadata to a
business object to aid searches, automatic aggregation and even data
mining potential (e.g. this user likes things with this particular tag,
so we can suggest them more content with similar tags).

Tagging is something that can even somewhat benefit from being unconstrained
and freely chosen as the item is added or updated. \cite{smith2008tagging}
It is also arguable that the harm in a tag being spelled incorrectly
on one programme is a minor harm (given it is additional metadata that
does not harm normal navigation nor basic application functions) when
compared to the benefit given to editors and content producers that
they can add as many tags freely as they please to their content items.

\subsubsection{Modelling programme categories}

Can we apply the same reasoning to the categories? Similarly to the
tags, we could consider adding them as an array type within the
Programme relation. Given they are more complex entities, we could
not easily store them as primitive strings, but the possibility of an
array of foreign key references to the Category relation is there. Another
option is that of an array of a custom \emph{composite} type.

With a composite type, we could create a category type and use that within
an array in our Programme relation. However, categories are likely to be
used very differently to tags in that they are commonly used to
drive hierarchical navigation in a user interface, allowing users
to browse categories of interest for the latest or most popular items
therewithin.

Given that we might (almost) equally query for programmes or categories,
we probably still want to keep their respective relations and rely on
JOIN queries to link the two when needed. It is not unreasonable to
expect an application where the categories themselves are rarely changed,
but programmes are individually added in frequent updates against these
relatively static categories. Thus we would have rare need for rapid,
expensive transactions where both tables need updating atomically. In
the rare cases where a category is added along with a programme,
we could easily pay the performance cost on such a one-off update.

The option of a composite type should be kept for consideration (perhaps
if further requirements gathering indicates it is a better approach),
but with the assumptions made so far, there seems to be little
case for it.

Another question is whether to model the hierarchical nature of the
category entity. The level attribute of a category (so far only values
\emph{1} and \emph{2} are observed) hints at a category hierarchy with
level 1 categories being root categories and level 2 categories being
children thereof. It is possible to model this using table
\emph{inheritence} within PostgreSQL. In this case, we could define
a Subcategory table that inherits the identifier and title attributes
from the Category table, but additionally adds a reference to any
other (sub)category indicating its parent.

Taking the approach of making tags string arrays within the programme
aggregate (for simplicity, performance and atomic updates) and using
inheritence to maintain a category hierarchy, we arrive at a final
candidate entity relationship design as shown in figure~\ref{fig:final_postgres}.

\begin{comment}
  @startuml plant_final_postgres.png
  class Programme {
    pid : varchar
    complete_title : varchar
    media_type : enum ['video, 'audio']
    masterbrand : varchar
    brand_pid : varchar
    is_clip : boolean
    tags : varchar[]
  }
  class AvailabilityWindow {
    start_time : timestamp
    end_time : timestamp
    service : varchar
  }
  class Category {
    id : varchar
    title : varchar
  }
  class Subcategory extends Category {
    parent : Category
  }
  Programme "1" -d- "0..*" AvailabilityWindow
  Programme "0..*" -r- "0..*" Category
  @enduml
\end{comment}
\begin{figure}[p]
  \begin{center}
    \includegraphics[width=\linewidth]{plant_final_postgres.png}
  \end{center}
  \caption{Candidate final design for PostgresSQL database}
  \label{fig:final_postgres}
\end{figure}

\subsection{Implementation}

With a design finalised, we can build a PostgreSQL database from
our data. A potential script that will create tables in the PostgreSQL
dialect of SQL is shown in figure~\ref{fig:create_table}.

\begin{figure}[p]
  \lstinputlisting[frame=single,language=SQL]{postgres_broken.sql}
  \caption{SQL script to create PostgreSQL tables for programme data}
  \label{fig:create_table}
\end{figure}

However, there is a problem with this schema. When we try to import the
data into these relations, PostgreSQL responds with an error:

\begin{verbatim}
ERROR:  insert or update on table "programme_category" violates\
 foreign key constraint "programme_category_category_id_fkey"
DETAIL:  Key (category_id)=(9200041) is not present in table \
"category".
\end{verbatim}

It seems that we are attempting to insert a link between a programme and
a category that doesn't exist. The ID 9200041 refers to a subcategory called
\emph{arts\_culture\_and\_the\_media}, underneath the \emph{factual} top-level
category. The problem we have encountered here is a limitation with the
inheritance model in PostgreSQL in that our foreign key from the
programme\_category relation to the category relation can only refer to things
that are strictly categories and not the subcategories. The child relation
of subcategory cannot inherit being a suitable reference from another table.
A similar limitation is seen again in that we have to define an explicit
primary key in the subcategory table as that is something else which
cannot inherit from a parent table.

The PostgreSQL documentation \cite{postgres-docs} confirms this to be the
case and moreover states ``There is no good workaround for this case.'' So,
we have to look at restructuring our schema a little as it appears that
the inheritance model in PostgreSQL is not as complete or pure as would
be expected from Object-Oriented Programming (OOP). In OOP, one important
principle is the Liskov Substitution Principle (LSP) that states -- at
a basic level -- that if some type $S$ is a subtype of a type $T$, then
any object or instance of $T$ may be swapped out for an object of
type $S$ without altering the behaviour of a programme or system.

PostgreSQL's inheritance model violates the Liskov Substituion Principle
in that our relation that refers to a category cannot have its foreign key
constrained field make a reference to the subcategory relation. In other
words, we are unable to use a subcategory logically everywhere we could
have used a category.

\begin{figure}[p]
  \lstinputlisting[frame=single,language=SQL,firstline=10,lastline=46]{postgres.sql}
  \caption{PostgreSQL script without using inheritance}
  \label{fig:flatten-category}
\end{figure}

There are a number of ways we could restructure our schema design to
avoid this limitation and a simple one is to eschew the inheritance feature
altogether and return to the ``old way'' -- a single category relation
with a nullable parent field (where a null parent indicates a top-level
category). This alteration is shown in figure~\ref{fig:flatten-category}.
This is a step back away from the object-relational model to the pure
relational model, but it seems the inheritance feature just was not
suitable for our needs in this case, but it may prove useful in other
situations.

\subsection{Querying}

With a schema design that now works and the CSV of programmes information
converted and imported into that schema, we can look at how we get
the information back out. Without formal requirements, we can only
suppose some of the use cases, but we can assume some relatively typical
needs. We can express these as questions as asked by an end user and then
look into the queries they would then translate into for the database.

We will also look at use cases where content editors may wish to update
or alter the information.

\subsubsection{What can I watch right now?}

This is a basic query where we seek everything where the start\_time is
in the past, but the end\_time is in the future:

\begin{lstlisting}[language=SQL]
  SELECT * FROM availability_window
    JOIN programme ON availability_window.pid = programme.pid
  WHERE start_time <= now() AND end_time >= now();
\end{lstlisting}

We should be able to trust the query optimisation to know to
narrow the availability\_window down to the relatively small set
of things available only now before doing the join to the larger
programme table.

\subsubsection{What categories are there?}

An application like BBC iPlayer may wish to query for a list of all
categories so as to create a navigation menu that allows users
to drill down into a particular category to see what is
available thereunder.

\begin{lstlisting}[language=SQL]
  SELECT * FROM category
  WHERE parent IS NULL
  ORDER BY title;
\end{lstlisting}

Note that we have to match on null parents to select only
top-level categories (we don't want to bombard a user with every
possible subcategory until they choose to drill down futher). Had
we been able to stick with our inheritance model that turned out
not to be possible, we could have had a arguably more elegant
query:

\begin{lstlisting}[language=SQL]
  SELECT * FROM ONLY category
  ORDER BY title;
\end{lstlisting}

Where the \emph{ONLY} keyword ensures we only return things that
are strictly categories and not from the subcategory child table.
This is arguably clearer as could be seen to follow the
\emph{Principle of Least Astonishment}
\cite{saltzer2009principles}
in that a programmer
is not having to be aware of explicitly adding ``parent IS NULL''
to a simple query for main categories only. It fits better with
the mental model of programmers familiar with object-oriented
programming to query for things of a given type than to filter
based on a field that a top-level category does not even have
at a semantic level. However, we are happy here to trade this
off if PostgreSQL's inheritance model does not support our needs.

\subsubsection{What subcategories are under my chosen category?}

We can query the category table to find, say, all subcategories under
the children's category:

\begin{lstlisting}[language=SQL]
  SELECT * FROM category
  WHERE parent = '9100001'
  ORDER BY title;
\end{lstlisting}

Again, we could have had a slightly clearer query with the inheritance
model:

\begin{lstlisting}[language=SQL]
  SELECT * FROM subcategory
  WHERE parent = '9100001'
  ORDER BY title;
\end{lstlisting}

Where it is arguably clearer we are specifically looking for a subcategory.
This is demonstrated further because we would be unable to do an accidental
attempt to find a top-level category with a parent:

\begin{lstlisting}[language=SQL]
  SELECT * FROM category
  WHERE parent = '9100001'
  ORDER BY title;
\end{lstlisting}

With the inheritance model, the query above would fail as the category
table has no parent field (only subcategories have parents), which
could be seen to be more robust against programmer error.

\subsubsection{What can I watch now within a single category?}

If our users have navigated to their favourite category, we probably want
to be able to query for everything that is available to watch right
now within that category only:

\begin{lstlisting}[language=SQL]
  SELECT * FROM availability_window
    JOIN programme ON availability_window.pid = programme.pid
    JOIN programme_category
      ON programme_category.pid = programme.pid
  WHERE start_time <= now() AND end_time >= now()
    AND programme_category.category_id = '9100001';
\end{lstlisting}

Note that we have no need to join on the whole category relation as the
navigation should have given us the category ID, which we can filter
sufficiently using only the programme\_category relation.

\subsubsection{What's become available to watch for a particular TV/Radio channel?}

This is a simple additional filter on the availability\_window relation:

\begin{lstlisting}[language=SQL]
  SELECT * FROM availability_window
    JOIN programme ON availability_window.pid = programme.pid
  WHERE start_time <= now() AND end_time >= now()
    AND service = 'bbc_one';
\end{lstlisting}

\subsubsection{What can I watch that has a given tag?}

This requires that we query within the tags array field:

\begin{lstlisting}[language=SQL]
  SELECT * FROM availability_window
    JOIN programme ON availability_window.pid = programme.pid
  WHERE start_time <= now() AND end_time >= now()
    AND 'history' = ANY(tags);
\end{lstlisting}

\subsubsection{I want to add a new programme}

Adding a new programme should be a simple, atomic insert into the programme
table:

\begin{lstlisting}[language=SQL]
  INSERT INTO programme
  (masterbrand, complete_title, pid, media_type, brand_pid, is_clip)
  VALUES
  ('cbbc', 'chucklevision:_series_18:_barryella', 'b0079214', 'video', 'b006w487', '0');
\end{lstlisting}

Fortunately, there is little inconsistency from simply adding links
to any existing categories in a subsequent update:

\begin{lstlisting}[language=SQL]
  INSERT INTO programme_category
  (pid, category_id)
  VALUES
  ('b0079214', '9100001');
\end{lstlisting}

It would not appear to be very harmful to have a programme in the database
that does not yet have categories assigned (users would simply not be able to
navigate to the programme easily until then) and there is no problem
with referential integrity between those two updates. If, however,
this situation is not acceptable even in a short time frame, we can bundle
these updates within a single transaction. It should be discussed in the
software requirements whether it is necessary to complicate the updates
if there is little risk of consistency problems. It is reasonable that
we would want our software to abandon the whole update if a content
editor tries to add a programme to a non-existent category. Again,
it is arguably more in line with the principle of least astonishment to
fail to add any programme information if there is a mistake in the transaction.

\subsubsection{I want to add a new programme with new tags}

It is trivial to include as many tags as we want in our original programme
insertion:

\begin{lstlisting}[language=SQL]
  INSERT INTO programme
  (tags, masterbrand, complete_title, pid, media_type, brand_pid, is_clip)
  VALUES
  ('{"comedy", "silly"}', 'cbbc', 'chucklevision:_series_18:_barryella', 'b0079214', 'video', 'b006w487', '0');
\end{lstlisting}

Due to the earlier decision to create the tags field as a denormalised, free-form
array of character strings against each programme, tagging a new programme
with new or existing tags is exactly the same operation. Our update is unaffected
by whether the tag is already present in the database or not. It is another
question for the software requirements gathering as to whether it is
acceptable that content editors can simply create tags in this loose manner (especially
if they are fully capable of creating tags with spelling mistakes).

\subsubsection{I want to add a new programme with a new category}

This is equivalent to inserting a new programme against an existing category,
except we must first do the update to insert the new category:

\begin{lstlisting}[language=SQL]
  INSERT INTO category (id, title) VALUES ('9100010', 'sport');
\end{lstlisting}

Again, there is a design decision to be made as to whether it is
acceptable for the category to be inserted with the programme update
then failing (and thus leaving the database with a category with no
programmes therewithin) or whether it is preferable to do all
three updates as a single transaction.

\subsubsection{I want to correct a spelling mistake in a title}

This is a simple, atomic update:

\begin{lstlisting}[language=SQL]
  UPDATE programme
  SET complete_title = 'new title'
  WHERE pid = 'abc123';
\end{lstlisting}

\subsubsection{I want to revoke a programme}

There may be a case where a planned broadcast of a programme is
cancelled for technical or legal reasons. If we have been populating
our on-demand/catch-up service database with the availability
window suggesting that users will be able to watch that programme soon,
we will want to be able to remove a programme's record and associated
availability.

In a more simpler case where we just want to remove the availability of
the programme to watch, we just need to remove its availability window
(if we lose the rights to let people watch the programme on-demand):

\begin{lstlisting}[language=SQL]
  DELETE FROM availability_window
  WHERE pid = 'abc123';
\end{lstlisting}

This deletion becomes less atomic if we need to cancel the programme
altogether (i.e. remove its existence altogether as it's not
even going to be broadcast on TV):

\begin{lstlisting}[language=SQL]
  DELETE FROM programme
  WHERE pid = 'abc123';
\end{lstlisting}

This deletion will break foreign key constraints unless we either
include a deletion of the availability window first or use
\emph{ON CASCADE DELETE} with our foreign key reference to ensure
that programme deletions always propagate to the
availability\_window table as well.

\section{XML Database}

In this section, we will explore importing the same programmes dataset
into an XML database. We will use \emph{eXist} as an example of such
a database system and step through the same design-implement-query
approach as used for PostgresSQL in section~\ref{sec:postgres}.

\subsection{Design}

Some of the discussion around the data model from section~\ref{sec:postgres}
will apply also as we look at a design for an XML database, but
in this section we can address any differences in the design approach.

In the initial stages, individual \emph{entities} were identified in the
dataset by stepping through the normalisation process methodically. It
is still valid that the entities we care about are \emph{programmes},
\emph{tags}, \emph{categories} (and \emph{subcategories}) and
\emph{availability windows}, but with XML we choose to structure these
very differently to the pure relation or the object-relational models.

With an XML database such as \emph{eXist}, schema design is not strictly
a barrier to being able to import information. So long as the data can
be expressed in valid XML, we are able to import it given the tendency
for XML databases to be intrinsically schemaless. Whilst this allows
greater flexibility for what we choose to store, it can be difficult
to query a database where all the documents have vastly different structures.
Simple things like whether a field is called ``title'' or ``heading''
can add unneeded complexity to querying applications that have to check
for multiple possible fields.

There is some value to keeping a consistent structure where possible
and the benefit of using XML in our data store is that we get all
the tooling and processes built for XML for free, including Xml Schema for
validating documents before we import them. We will thus look at creating
an XML Schema document (XSD) as part of the design phase, which we can
use to validate document as we import them.

We can use \lstinline|<xs:complexType>| to define a grouping of elements
in a way that is analogous to defining a relation in a purely relational
schema. In fact, an XML node and all its descendent nodes are actually an
example of the \emph{aggregate model} in that a node tree defines an
atomic entity with as much structure and complexity within that
aggregate as necessary (i.e. it does not have to be a flat relation in
normal form). In this way, we could design in such as way as to have
a complexType defining an XML subtree for each object-relational aggregate
we defined for PostgreSQL.

Following the principle of a complexType per entity, we could create
a schema like that shown in figure~\ref{fig:xsd}.

\begin{figure}[p]
  \lstinputlisting[frame=single,language=XML,basicstyle=\scriptsize]{programmes.xsd}
  \caption{XSD defining a complexType for each of our aggregates}
  \label{fig:xsd}
\end{figure}

We have a simpleType which parallels the custom enum type used in the
PostgreSQL database as well as a complexType per entity in the entity
relational diagram shown in figure~\ref{fig:final_postgres}. There is one
exception in that subcategories have not been modelled as a separate
type. With XML we can use its hierachical, nested nature to compose
a tree of categories (in that each \lstinline|<category>| tag may
itself have its own \lstinline|<categories>| tag). Query languages such
as Xpath and Xquery should permit us to search for top-level categories
only, subcategories only and even across all categories and subcategories
together (since their respective XML subtrees share the same complexType and
are thus isomorphic). These three possibilities are what we would want
from an inheritance model, so this nested composition could be said
to be equivalent to subcategories inheriting from a parent category type.

One important thing to note is that we have now denormalised the
categories and replicated them across each programme. This has
added a lot of redundancy, but is a simpler approach that makes better
use of the hiearchical nature of XML, whereas references and foreign
keys are not natively possible with XML documents. We will see how
simple this keeps the queries when we come to pull information back
out of the database.

\subsection{Implementation}

We can convert the data from the original CSV into multiple XML documents
similar to the example shown in figure~\ref{xml-example} and then import
into eXist with a single command:

\begin{lstlisting}
$ $EXIST_HOME/bin/client.sh -m /db/programmes -p *.xml
\end{lstlisting}

\begin{figure}[p]
  \lstinputlisting[
  frame=single,language=XML,basicstyle=\scriptsize,breakatwhitespace=false
  ]{
    xml/b00sn5cy.xml
  }
  \caption{Example XML representation of a programme}
  \label{fig:xml-example}
\end{figure}

\subsection{Querying}

In this section, we see how to query the XML collection using Xquery to
achieve the same queries as performed in PostgreSQL.

\subsubsection{What can I watch right now?}

Rather than the join operator used in SQL, we can search amongst
the nested availability windows using XQuery:

\begin{lstlisting}
xquery version "3.0";
for $programme in //programme
where $programme/availability/window/start_time < current-dateTime()
  and $programme/availability/window/end_time > current-dateTime()
return $programme
\end{lstlisting}

\subsubsection{What categories are there?}

This is where the denormalisation of the categories becomes a difficulty.
In order to find all unique top-level categories, we have to query all
category tags across all programmes and aggregate them down to unique
categories only:

\begin{lstlisting}
xquery version "3.0";
let $all_categories := //programme/categories/category
for $category_id in distinct-values($all_categories/id)
let $categories := $all_categories[id=$category_id]
let $category_title := $categories[1]/title/text()
order by $category_title
return 
    <category>
        <id>{$category_id}</id>
        <title>{$category_title}</title>
    </category>
\end{lstlisting}

In this case, we may have wished to create an XML collection for just
category XML documents to aid quick retrieval of all categories. However,
it becomes less clear how to maintain some referential integrity
between programmes and their respective categories.

\subsubsection{What subcategories are under my chosen category?}

This is similar to the previous query:

\begin{lstlisting}
xquery version "3.0";

let $all_subcategories := //programme/categories/category[id="9100098"]/categories/category
for $subcategory_id in distinct-values($all_subcategories/id)
let $subcategories := $all_subcategories[id=$subcategory_id]
let $subcategory_title := $subcategories[1]/title/text()
order by $subcategory_title
return 
    <category>
        <id>{$subcategory_id}</id>
        <title>{$subcategory_title}</title>
    </category>
\end{lstlisting}

The advantage with the nested XML design is that we can alter the XPath at
the top of the query to search all categories whether they are subcategories
or not and we can easily scale to arbitrary levels of category nesting.

\subsubsection{What can I watch now within a single category?}

We can query for all available programmes within a given category or even subcategory:

\begin{lstlisting}
xquery version "3.0";
for $programme in //programme[descendant::category/id='9200010']
where $programme/availability/window/start_time < current-dateTime()
  and $programme/availability/window/end_time > current-dateTime()
return $programme
\end{lstlisting}

\subsubsection{What's become available to watch for a particular TV/Radio channel?}

We can alter the first query to make sure we only match on availability of
programmes broadcast originally on BBC One:

\begin{lstlisting}
xquery version "3.0";
for $programme in /programme
where $programme/availability/window[service='bbc_one']/start_time < current-dateTime()
  and $programme/availability/window[service='bbc_one']/end_time > current-dateTime()
return $programme
\end{lstlisting}

This turns out to be a very inefficient query without indexes. We should ensure
that our eXist DB collection is indexing on the service field.

\subsubsection{What can I watch that has a given tag?}

We can search for available programmes with a given tag:

\begin{lstlisting}
xquery version "3.0";
for $programme in //programme
where $programme/tags/tag/text() = 'science'
  and $programme/availability/window/start_time < current-dateTime()
  and $programme/availability/window/end_time > current-dateTime()
return $programme
\end{lstlisting}

\subsubsection{I want to add a new programme}

With eXist-db, there are multiple ways to import whole new documents. One
simple way for us to add a new programme document to the collection
is to use the command line Java admin client:

\begin{lstlisting}
bin/client.sh -m /db/programmes -p /path/to/xml/files
\end{lstlisting}

Alternatively, we can use XQuery Update syntax to add the new document:

\begin{lstlisting}
xquery version "3.0";
declare namespace xmldb="http://exist-db.org/xquery/xmldb";
xmldb:store('/db/programmes', 'abc123.xml', '<programe>...</programme>')
\end{lstlisting}

\subsubsection{I want to add a new programme with new tags}

Given that are tags for a programme are contained within each programme
document, there is nothing preventing entirely new tags being included
in any document adding in the previous manner.

\subsubsection{I want to add a new programme with a new category}

Similarly to tags, categories are denormalised through all documents, so
we can use any of the available ways to add new documents to include
any categories -- new or existing -- in those documents.

\subsubsection{I want to correct a spelling mistake in a title}

We can remove a document and add a replacement if our client
software simple wants to send a full document (based on an editor
changing the information in a form and submitting it):

\begin{lstlisting}
xquery version "3.0";
declare namespace xmldb="http://exist-db.org/xquery/xmldb";
let $file-name := 'abc123.xml'
let $remove-return-status := xmldb:remove('/db/programmes, $file-name)
xmldb:store('/db/programmes', $file-name, <programe>...</programme>)
\end{lstlisting}

Another way is to do a direct update on the document node itself:

\begin{lstlisting}
xquery version "3.0";
replace value of node fn:doc("abc123.xml")/programme/title
with 'New title'
\end{lstlisting}

\subsubsection{I want to revoke a programme}

\begin{lstlisting}
xquery version "3.0";
declare namespace xmldb="http://exist-db.org/xquery/xmldb";
let $file-name := 'abc123.xml'
xmldb:remove('/db/programmes, $file-name)
\end{lstlisting}

%$ <- makes emacs happy

\section{Document Database}
\subsection{Design}
\subsection{Implementation}
\subsection{Querying}
\subsubsection{What can I watch right now?}
\subsubsection{What categories are there?}
\subsubsection{What subcategories are under my chosen category?}
\subsubsection{What can I watch now within a single category?}
\subsubsection{What's become available to watch for a particular TV/Radio channel?}
\subsubsection{What can I watch that has a given tag?}
\subsubsection{I want to add a new programme}
\subsubsection{I want to add a new programme with new tags}
\subsubsection{I want to add a new programme with a new category}
\subsubsection{I want to correct a spelling mistake in a title}
\subsubsection{I want to revoke a programme}

\section{Comparison}

\bibliographystyle{cell}
\bibliography{bibtex}
\end{document}
